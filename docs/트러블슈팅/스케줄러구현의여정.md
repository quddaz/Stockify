# 스케줄러 구현의 여정

이번 프로젝트에서 저는 **주식 투자 가상 서비스**의 스케줄러를 구현했습니다. <br>
이 과정에서 여러 문제와 도전과제를 마주했고, 이를 해결하기 위해 다양한 시도를 했습니다. <br>
이 글에서는 제가 겪은 문제와 그 해결 과정을 공유하고자 합니다.

---

## 요구사항 분석 및 설계

처음에는 스케줄러가 수행해야 할 기능을 명확히 정의했습니다. <br>
예를 들어, 주식 데이터 업데이트, 이벤트 발생, 격동 테마 적용, 장 마감 등이 있었습니다. <br>
이를 바탕으로 스케줄러의 구조와 동작 방식을 설계했습니다.

| 항목    | 주기     | 설명                      |
| ----- | ------ |-------------------------|
| 주가 갱신 | 5분     | 전체 주식 랜덤 변동             |
| 사건 생성 | 15~30분 | 사건(Event) 기반 랜덤 주식 변동   |
| 랭킹 갱신 | 2시간    | 사용자 수익률 재계산             |
| 장 마감  | 2시간    | 보유 주식 강제 매도 및 사용자 자금 리셋 |

---

## 스케줄러 구현 과정

### 1. 주기적 작업 스케줄링

처음에는 Spring의 `@Scheduled`를 사용해 주기적 작업을 구현했습니다.

```kotlin
@Scheduled(fixedRate = 300_000) // 5분마다 실행
fun updateStockPrices() { /* 주가 업데이트 */ }

@Scheduled(fixedRate = 1_500_000) // 15~30분마다 실행
fun generateEvent() { /* 사건 변동 */ }

@Scheduled(fixedRate = 7_200_000) // 2시간마다 실행
fun closeMarket() { /* 장 마감 */ }
```

* 간단하고 직관적이었지만, **작업 간 의존성 관리와 오류 처리**에는 한계가 있었습니다.

    * 예: 주가 갱신 작업과 사건 생성 작업이 동시에 실행되면 순서 예측이 어려움
    * 하나의 작업 실패 시 전체 스케줄러에 영향을 미칠 수 있음(예 : 테스크 실패로 인한 예상치 못한 변동 발생)

* 특히, 요구사항상 **이벤트 작업이 실행되면 주가 업데이트는 건너뛰어야 하는 상황**이 있었기 때문에,
  작업 간 의존성을 명확히 관리할 필요가 있었습니다.

---

### 2. 작업 순서 보장

이를 해결하기 위해 **전략 패턴**을 도입했습니다.
각 작업을 `Task` 인터페이스로 정의하고, 실행 순서에 따라 클래스별로 구현했습니다.

```kotlin
interface Task {
    fun canExecute(): Boolean
    fun execute()
}

@Order(1) // 우선순위 지정
class EventTask : Task {
    override fun canExecute(): Boolean { /* 조건 판단 */ }
    override fun execute() { /* 주가 업데이트 */ }
}

class StockifyMainTaskScheduler(
    private val tasks: List<Task> // Spring이 Order를 통해 정렬된 Task 주입
) {
    @Scheduled(fixedRate = 300_000)
    fun runTasks() {
        for (task in tasks) {
            if (task.canExecute()) task.execute()
        }
    }
}
```

* `canExecute()`를 통해 실행 가능 여부를 판단하고, **순차적으로 Task 실행** 가능
* 작업 간 의존성을 명확히 하고, 오류 발생 시 다른 작업에 영향이 가지 않도록 설계

<br>
그러나 이벤트가 순차적으로 실행되는 것만 보장할 뿐, **동시에 실행되는 작업 간의 의존성**을 해결하지는 못했습니다.

---

### 3. 작업 그룹 관리

문제 해결을 위해 **작업 그룹** 개념을 도입했습니다.

```kotlin
enum class TaskGroup { EVENT, SECTOR_UPDATE, RANKING_UPDATE, MARKET_CLOSE }

interface Task {
    val mainTask: TaskGroup
    val taskGroup: List<TaskGroup>
    fun canExecute(): Boolean
    fun execute()
}

@Order(1)
class EventTask : Task {
    override val mainTask = TaskGroup.EVENT
    override val taskGroup = listOf(TaskGroup.MARKET_CLOSE, TaskGroup.SECTOR_THEME, TaskGroup.EVENT)

    override fun canExecute(): Boolean { /* 실행 조건 */ }
    override fun execute() { /* 주가 업데이트 */ }
}
```

* 각 Task가 속한 그룹을 기준으로 **실행 순서와 의존성을 관리**
* 최상위 그룹(TaskGroup.MARKET_CLOSE)이 실행되면, 하위 테스크가 최상위 그룹을 포함하는지 확인 후 실행 여부 결정 (예: SECTOR_THEME Task는 MARKET_CLOSE 그룹에 속하므로 함께 실행)
* OOP 설계를 활용해 **각 Task를 독립적인 클래스**로 분리, 전략 패턴 적용 → 유지보수성과 확장성 향상

---

### 4. 최종 스케줄러 구조

최종적으로 스케줄러 구조는 다음과 같이 정리했습니다.

```kotlin
@Scheduled(cron = "0 */5 * * * *")
fun runScheduledTasks() {
    val now = LocalDateTime.now()
    log.info("스케줄러 실행 $now")

    val executableTasks = filterExecutableTasks(now) // 실행 가능한 Task 필터링
    if (executableTasks.isEmpty()) return

    val mainGroup = getMainGroup(executableTasks)   // 메인 Task 그룹 결정
    log.info("실행되는 메인 Task 그룹: $mainGroup")

    executeGroupTasks(executableTasks, mainGroup)  // 해당 그룹 Task 실행
}
```

* **실행 순서와 그룹**을 명확히 관리 가능
* **오류 발생 시 다른 Task 영향 최소화**
* OOP 장점 활용 → 독립적 클래스, 전략 패턴 적용, 확장성/유지보수성 향상

---

## 결론

이번 스케줄러 구현 과정은 **다양한 도전과제를 직접 해결하며 성장할 수 있었던 여정**이었습니다. <br>
각 문제마다 **다양한 접근 방식을 시도**했고, 최종적으로 **작업 그룹과 전략 패턴을 활용한 설계**를 통해 문제를 효과적으로 해결했습니다. <br>
이 과정을 통해 저는 **빈번한 요구사항 변경에도 유연하게 대응할 수 있는 스케줄러**를 구현할 수 있었으며, <br>
<br>
이는 **OOP와 전략 패턴을 적용한 설계의 강력함과 안정성**을 직접 경험한 사례이기도 합니다. <br>
<br>
앞으로도 이러한 경험을 바탕으로 **더 나은 설계와 구현을 추구하며 안정적이고 확장성 있는 시스템 개발**에 힘쓸 것입니다. <br>
**감사합니다.**

