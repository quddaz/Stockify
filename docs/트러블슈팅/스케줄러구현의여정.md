# 스케줄러 구현의 여정

이번 프로젝트에서 저는 **주식 투자 가상 서비스**의 스케줄러를 구현했습니다.
이 과정에서 여러 문제와 도전과제를 마주했고, **다양한 시도와 시행착오**를 통해 최종 구조를 완성했습니다.
아래에서는 구현 여정을 중심으로 문제와 해결 과정을 공유합니다.

---

## 1. 요구사항 분석 및 초기 설계

처음에는 스케줄러가 수행해야 할 기능을 명확히 정의했습니다.

| 항목    | 주기     | 설명                       |
| ----- | ------ | ------------------------ |
| 주가 갱신 | 5분     | 전체 주식 랜덤 변동              |
| 사건 생성 | 15~30분 | 사건(Event) 기반 랜덤 주식 변동    |
| 랭킹 갱신 | 2시간    | 사용자 수익률 재계산              |
| 장 마감  | 2시간    | 보유 주식 강제 매도 및 사용자 자금 초기화 |

* 초기 설계에서는 단순히 `@Scheduled`만으로 주기적 작업을 구현했지만,
  **작업 간 의존성, 순서 보장, 오류 처리** 문제를 해결할 필요가 있었습니다.

---

## 2. 초기 구현과 문제점

```kotlin
@Scheduled(fixedRate = 300_000)
fun updateStockPrices() { /* 주가 업데이트 */ }

@Scheduled(fixedRate = 1_500_000)
fun generateEvent() { /* 사건 변동 */ }

@Scheduled(fixedRate = 7_200_000)
fun closeMarket() { /* 장 마감 */ }
```

* 장점: 단순하고 직관적
* 단점:

  1. **작업 간 순서 예측 어려움** → 주가 갱신과 사건 생성이 겹치면 순서가 뒤바뀜
  2. **오류 전파 문제** → 하나의 작업 실패 시 전체 스케줄러에 영향
  3. **조건부 실행 관리 불가** → 이벤트 발생 시 주가 업데이트를 건너뛰어야 하는 경우 처리 어려움

이 문제를 해결하기 위해 구조를 개선했습니다.

---

## 3. Task 인터페이스와 전략 패턴 도입

```kotlin
interface Task {
    val mainTask: TaskGroup
    val taskGroup: List<TaskGroup>
    fun canExecute(time: LocalDateTime): Boolean
    fun execute()
}
```

* 각 작업을 **독립적인 클래스**로 분리
* 실행 조건(`canExecute`)과 실행 로직(`execute`)을 명확히 분리
* **전략 패턴** 적용 → 확장 및 유지보수 용이

---

## 4. Task 그룹과 의존성 관리

```kotlin
enum class TaskGroup { EVENT, SECTOR_THEME, CHANGE, MARKET_CLOSE }
```

* Task는 **mainGroup과 관련 그룹**을 정의
* 스케줄러는 **메인 그룹 기준으로 실행** → 하위 Task에 영향 최소화
* 예: `MARKET_CLOSE` 그룹이 실행되면 하위 CHANGE Task는 자동 건너뛰기

---

## 5. TaskSelector와 TaskExecutor

```kotlin
val executableTasks = taskSelector.filterExecutableTasks(now)
val mainGroup = taskSelector.getMainGroup(executableTasks)
taskExecutor.executeGroupTasks(executableTasks, mainGroup)
```

* `TaskSelector` → 실행 가능 여부 필터링, 메인 그룹 결정
* `TaskExecutor` → Task 단위 **재시도 로직 포함**, 실패 Task는 재시도 후 예외 throw

```kotlin
fun executeGroupTasks(executableTasks: List<PrioritizedTask>, mainGroup: TaskGroup) {
    executableTasks
        .filter { it.mainTask == mainGroup }
        .forEach { task ->
            retry(times = 3, delayMs = 1000) {
                log.info("테스크 실행: ${task.mainTask}")
                task.execute()
            }
        }
}
```

* 재시도 헬퍼(`retry`) 사용 → 반복문과 try-catch를 깔끔하게 처리
* Task 단위 실패 시 다른 Task에 영향 최소화

---

## 6. StockUpdatePublisher

```kotlin
stockUpdatePublisher.publishStockUpdate()
stockUpdatePublisher.publishMarketClose(mainGroup)
```

* 시뮬레이션 특성상 **주식 데이터 캐시 갱신과 장마감 이벤트 처리**만 담당
* WebSocket 전송은 선택적, 실제 프론트 연동 없이도 스케줄러 동작 가능

---

## 7. 최종 스케줄러 구조

```kotlin
@Scheduled(cron = "0 */5 * * * *")
fun runScheduledTasks() {
    val now = LocalDateTime.now()
    log.info("스케줄러 실행 $now")

    val executableTasks = taskSelector.filterExecutableTasks(now)
    if (executableTasks.isEmpty()) return
    
  
    // Task 실행
    val mainGroup = taskSelector.getMainGroup(executableTasks)
    taskExecutor.executeGroupTasks(executableTasks, mainGroup)
  
    //WebSocket 전송 및 로컬 캐시 갱신
    stockUpdatePublisher.publishStockUpdate()
    stockUpdatePublisher.publishMarketClose(mainGroup)
}
```

* **실행 순서와 그룹 관리** → 순차적, 안정적 Task 수행
* **Task 단위 재시도** → 실패에도 전체 스케줄러 안정성 유지
* **OOP 기반 설계** → 유지보수성과 확장성 확보

---

## 8. 구현 여정에서의 배움

1. **단순한 주기적 스케줄러**에서 시작 → 점점 **작업 그룹, 의존성, 재시도 로직** 도입
2. **전략 패턴과 Task 인터페이스** 적용 → Task 추가/수정 용이
3. **재시도 헬퍼**로 안정적 실행 확보 → 시뮬레이션 특성에 맞춘 오류 처리
4. **OOP 설계 경험** → 요구사항 변화에도 유연하게 대응 가능한 구조 완성

---

## 결론

이번 스케줄러 구현 과정은 **시행착오와 문제 해결**의 연속이었지만,
그 과정에서 얻은 경험은 앞으로 **안정적이고 확장성 있는 시스템 설계**에 큰 자산이 되었습니다.

* **OOP + 전략 패턴 + Task 그룹 + 재시도 로직**의 조합으로 안전하고 확장 가능한 스케줄러 구현
* 빈번한 요구사항 변경에도 유연하게 대응 가능

이번 경험을 통해 **더 나은 설계와 안정적인 시스템 구현**에 한 걸음 다가갔다고 생각합니다.