# 주식 매도/매수와 동시성

주식 거래 시스템에서 매수와 매도는 동시에 발생할 수 있으며, 이러한 동시성 문제를 효과적으로 관리하는 것이 중요합니다.
이 문서에서는 주식 매수/매도와 관련된 동시성 문제를 해결하는 과정과 Stockify에서의 구현 방안을 설명합니다.

---

## 1. 동시성 문제 이해

동시성 문제는 여러 사용자가 동시에 동일한 주식에 대해 매수 또는 매도 요청을 보낼 때 발생할 수 있습니다.
예를 들어, 두 사용자가 동시에 동일한 주식을 매수하려고 할 때, 시스템이 이를 올바르게 처리하지 못하면 **재고 부족**이나 **잘못된 거래**가 발생할 수 있습니다.

---

## 2. Stockify에서의 동시성 관리

Stockify에서는 다음 부분에서 동시성 문제가 발생할 수 있습니다:

* **주식 잔고 업데이트**: 매수 또는 매도 시 주식 잔고를 업데이트하는 과정에서 동시성 문제가 발생
* **스케줄러 작업**: 정기적으로 실행되는 작업이 주식 잔고를 변경할 때 매수/매도 요청과 충돌 가능

---

### 2.1 주식 잔고 업데이트 관리

주식 잔고 업데이트 시 동시성 문제를 방지하기 위해 다음 방법을 사용합니다:

1. **트랜잭션 사용**
   데이터베이스 트랜잭션을 사용하여 매수/매도 작업이 원자적으로 수행되도록 합니다.
   → 작업 중 실패하더라도 데이터 일관성을 유지 가능

2. **비관적 락 사용**
   주식 잔고를 업데이트할 때 해당 레코드에 락을 걸어 다른 트랜잭션이 동시에 접근하지 못하도록 합니다.

#### 비관적 락 적용 대상

* **Company**: 남은 주식 수량
* **User_Position**: 유저가 보유한 주식 수량

> User 도메인은 트랜잭션 내에서 단일 사용자가 접근하므로, 동시에 접근될 가능성이 거의 없어 비관적 락이 필요하지 않습니다.

> Company와 User_Position은 여러 트랜잭션에서 동시에 수정될 수 있으므로 비관적 락 적용

#### 예시 코드

```kotlin
@Transactional
fun buy(userId: Long, companyId: Long, quantity: Long) {
    val user = userService.findById(userId)
    val company = companyService.findByIdForUpdate(companyId)

    val totalCost = quantity * company.currentPrice

    // 유저 자금 차감
    user.spend(totalCost)

    // 회사 주식 수 감소
    company.decreaseShares(quantity)

    // 포지션 락 + 조회
    val position = positionRepository.findByUserIdAndCompanyIdForUpdate(userId, companyId)
        ?: UserPosition(user = user, company = company, quantity = 0L, averagePrice = 0L)

    position.buy(quantity, company.currentPrice)

    if (position.id == null) {
        positionRepository.save(position)
    }
}

@Transactional
fun sell(userId: Long, companyId: Long, quantity: Long, price: Long) {
    val user = userService.findById(userId)
    val company = companyService.findByIdForUpdate(companyId)

    val position = positionRepository.findByUserIdAndCompanyIdForUpdate(userId, companyId)
        ?: throw UserPositionDomainException(UserPositionErrorCode.POSITION_NOT_FOUND)

    position.sell(quantity)
    user.earn(quantity * price)
    company.increaseShares(quantity)

    if (position.quantity == 0L) {
        positionRepository.delete(position)
    }
}
```

---

### 2.2 스케줄러 작업 관리

초기 설계에서는 비관적 락만으로 충분하다고 생각했지만, 스케줄러가 주식 잔고를 변경하는 동안 매수/매도 요청이 들어오면 충돌이 발생할 수 있습니다.

이를 해결하기 위해 다음 두 가지 방안을 고려했습니다:

1. **스케줄러 작업과 매수/매도 작업 분리**
   → 스케줄러 작업 수행 중 매수/매도 요청을 일시적으로 차단
   → 구현 복잡도 상승

2. **메시지 큐를 통한 순차 처리** (선택)
   → 매수/매도 요청과 스케줄러 작업을 메시지 큐를 통해 순차 처리
   → 충돌 방지, 확장성 및 유연성 확보

> Stockify는 두 번째 방안을 선택했습니다.
>
> * Scheduler는 **mainTaskGroup Enum만 MQ에 전송**
> * Consumer에서 **TaskSelector + TaskExecutor**를 활용하여 실행
> * 메시지 큐를 통해 모든 작업이 순차적으로 안전하게 처리됩니다

---

## 3. MQ 선정 (RabbitMQ vs Kafka)

메시지 큐로는 **RabbitMQ**를 선택했습니다.

* 이유

    * 설정과 사용이 비교적 간단
    * 순서 보장이 필요한 현재 프로젝트 요구사항에 적합
    * 스케줄러 + 매수/매도 이벤트를 순차 처리 가능

* Kafka와 비교

    * Kafka는 대용량 데이터 처리 및 복잡한 메시징 패턴에 최적화
    * 현재 프로젝트에는 과도한 선택
    * 추후 다중 서비스 확장 시 도입 가능

---

### 4. 메시지 처리 흐름 (예시)

```
Scheduler
   │
   └──> TradeProducer.sendScheduler(mainTaskGroup)
            │
            └──> RabbitMQ Queue
                      │
Consumer
   │
   │
   └──> TaskExecutor.executeGroupTasks(tasks, mainTaskGroup)
          │
          └──> StockUpdatePublisher.publishStockUpdate() // WebSocket 퍼블리시
           ──> StockUpdatePublisher.publishMarketClose(mainTaskGroup) // WebSocket 퍼블리시
```

* Scheduler는 메시지 전송만 수행 → 블로킹 문제 없음
* Consumer에서 모든 Task 실행 및 WebSocket 퍼블리시 처리

